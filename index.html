<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TS ECET Quiz Master — CBT Mode (Stable)</title>
  <style>
    :root{--bg:#0a0e1a;--panel:#151a28;--accent:#00ff88;--muted:#9aa3b2;--gold:#ffd700;--danger:#ff3366;--card:#1a1f2e}
    html,body{height:100%;margin:0;font-family:Inter, Rajdhani, system-ui, sans-serif;background:linear-gradient(135deg,var(--bg),#0b0f1a);color:#e8f0ff}
    .wrap{max-width:1100px;margin:20px auto;padding:20px}
    .card{background:linear-gradient(145deg,var(--card),#12151d);border-radius:12px;padding:18px;border:2px solid rgba(0,255,136,0.06);box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    header h1{font-family:Orbitron, sans-serif;font-size:20px;margin:0 0 6px}
    header p{color:var(--muted);margin:0 0 12px}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    input[type=text],select,textarea{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{padding:10px 12px;border-radius:8px;border:none;cursor:pointer;background:linear-gradient(90deg,var(--accent),#00d4ff);color:#041017;font-weight:700}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .muted{color:var(--muted)}
    .error{color:var(--danger);font-weight:700}
    .flex{display:flex;gap:10px;align-items:center}
    .small{font-size:13px}
    .hidden{display:none}
    .question-card{margin-top:18px}
    .option{padding:10px;border-radius:8px;margin:8px 0;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
    .option.selected{outline:3px solid rgba(0,255,136,0.12)}
    .option.correct{background:rgba(0,255,136,0.08);border-color:rgba(0,255,136,0.2)}
    .option.wrong{background:rgba(255,51,102,0.06);border-color:rgba(255,51,102,0.15)}
    .footer{margin-top:18px;text-align:center;color:var(--muted)}
    pre.debug{background:#071018;padding:10px;border-radius:8px;color:#bfeee0;max-height:160px;overflow:auto;font-size:12px;white-space:pre-wrap}
    @media (max-width:640px){.controls{flex-direction:column}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="loader-card">
      <header>
        <h1>TS ECET Quiz Master — Loader & CBT Setup</h1>
        <p class="muted">Load <code>questions.json</code> (must include subjects). This loader accepts file upload, paste, or URL. CBT mode will assemble 200 unique questions: Math 50, Physics 25, Chemistry 25, CSE 100.</p>
      </header>

      <div id="loader-ui">
        <div class="controls">
          <button id="try-fetch">Try fetch('./questions.json')</button>
          <input type="file" id="file-input" accept="application/json" />
          <button id="paste-json" class="ghost">Paste JSON</button>
          <input type="text" id="fetch-url" placeholder="Or enter full URL to JSON (https://...)" />
          <button id="fetch-url-btn">Fetch URL</button>
        </div>

        <div style="margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
          <div class="small muted">Loader status:</div>
          <div id="loader-status" class="small">Not attempted</div>
        </div>

        <div id="loader-debug" style="margin-top:12px" class="hidden">
          <div class="small muted">Debug output:</div>
          <pre id="debug-pre" class="debug" aria-live="polite"></pre>
        </div>

        <div style="margin-top:14px">
          <button id="continue-with-sample" class="ghost">Continue with sample questions</button>
        </div>
      </div>
    </div>

    <div class="card hidden" id="app-card">
      <div id="app-container">
        <!-- App content injected here -->
      </div>
    </div>

    <div class="footer">If you deploy to GitHub Pages, ensure <code>questions.json</code> is in the repository root (not in /src or hidden by .gitignore).</div>
  </div>

  <script>
    // SAFE, stable loader + CBT assembler
    const DEFAULT_SAMPLE = [
      { id: 1, question: 'What is 2 + 2?', options: ['1', '2', '3', '4'], correct: 3 },
      { id: 2, question: 'Which language is used for web pages?', options: ['Python','HTML','C++','Java'], correct: 1 }
    ];

    const CBT_DISTRIBUTION = { Mathematics: 50, Physics: 25, Chemistry: 25, CSE: 100 };
    const TIME_PER_QUESTION = 60; // seconds

    let allSubjectsData = {};
    let quizData = [];
    let currentScreen = 'welcome';
    let userName = '';
    let currentQuestionIndex = 0;
    let score = 0;
    let userAnswers = [];
    let remainingSeconds = 0;
    let timerInterval = null;

    const el = id => document.getElementById(id);

    function safeForDebug(msg){
      // Convert to string and escape non-printable control characters except \n, \r, \t
      const s = String(msg === undefined ? 'undefined' : msg);
      return s.replace(/[\u0000-\u001F\u007F-\u009F]/g, ch => {
        if (ch === '\n' || ch === '\r' || ch === '\t') return ch;
        return '\\u' + ch.charCodeAt(0).toString(16).padStart(4, '0');
      });
    }

    function debug(msg){
      try{
        console.log(msg);
        const safe = safeForDebug(msg);
        const pre = el('debug-pre');
        if (pre) {
          pre.textContent += safe + '\n';
          el('loader-debug').classList.remove('hidden');
        }
      }catch(e){
        try{ console.log('debug write failed', e); }catch(_){}
      }
    }

    function escapeControlCharsToUnicode(s){
      const str = String(s || '');
      return str.replace(/[\u0000-\u001F\u007F-\u009F]/g, ch => {
        if (ch === '\n' || ch === '\r' || ch === '\t') return ch;
        return '\\u' + ch.charCodeAt(0).toString(16).padStart(4,'0');
      });
    }

    function parseAndSetJSON(text){
      try{
        let cleaned = String(text).replace(/\f/g, '');
        try{
          const data = JSON.parse(cleaned);
          setSubjectsFromData(data, 'direct');
          el('loader-status').textContent = 'Loaded '+Object.keys(allSubjectsData).length+' subject(s)';
          debug('Loaded subjects: ' + Object.keys(allSubjectsData).join(', '));
          return true;
        }catch(innerErr){
          debug('Initial JSON.parse failed: '+innerErr.message+' — attempting repair');
          const escaped = escapeControlCharsToUnicode(cleaned);
          try{
            const data = JSON.parse(escaped);
            setSubjectsFromData(data, 'repaired');
            el('loader-status').textContent = 'Loaded (repaired) '+Object.keys(allSubjectsData).length+' subject(s)';
            debug('Loaded (repaired) subjects: ' + Object.keys(allSubjectsData).join(', '));
            return true;
          }catch(repairErr){
            debug('Repair attempt failed: '+repairErr);
            el('loader-status').textContent = 'JSON parse error: '+repairErr.message;
            return false;
          }
        }
      }catch(e){
        debug('JSON parse error: '+e);
        el('loader-status').textContent = 'JSON parse error: '+e.message;
        return false;
      }
    }

    function setSubjectsFromData(data, tag){
      if (data && typeof data === 'object' && data.subjects) {
        allSubjectsData = data.subjects;
        debug('setSubjectsFromData: used data.subjects ('+tag+')');
      } else if (Array.isArray(data)){
        allSubjectsData = { General: data };
        debug('setSubjectsFromData: used array -> General ('+tag+')');
      } else if (data && typeof data === 'object'){
        allSubjectsData = data;
        debug('setSubjectsFromData: used object keys as subjects ('+tag+')');
      } else {
        throw new Error('Unsupported JSON structure');
      }
    }

    // File input
    el('file-input').addEventListener('change', async (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      el('loader-status').textContent = 'Reading file '+f.name;
      const txt = await f.text();
      const ok = parseAndSetJSON(txt);
      if (ok) openApp();
    });

    el('paste-json').addEventListener('click', ()=>{
      const txt = prompt('Paste the full JSON content for questions.json');
      if (!txt) return;
      const ok = parseAndSetJSON(txt);
      if (ok) openApp();
    });

    async function tryLoadFromPath(path = './questions.json'){
      el('loader-status').textContent = `Fetching ${path}...`;
      try{
        const res = await fetch(path, {cache:'no-store'});
        if (!res.ok) throw new Error('HTTP '+res.status+' - '+res.statusText);
        const txt = await res.text();
        return parseAndSetJSON(txt);
      }catch(err){
        debug('Failed to load questions: ' + String(err));
        el('loader-status').textContent = 'Failed to load: '+err.message;
        return false;
      }
    }

    el('try-fetch').addEventListener('click', async ()=>{
      const pre = el('debug-pre'); if (pre) pre.textContent = '';
      await tryLoadFromPath('./questions.json');
      if (Object.keys(allSubjectsData).length) openApp();
    });

    el('fetch-url-btn').addEventListener('click', async ()=>{
      const url = el('fetch-url').value.trim();
      if (!url) return alert('Enter URL');
      const pre = el('debug-pre'); if (pre) pre.textContent = '';
      await tryLoadFromPath(url);
      if (Object.keys(allSubjectsData).length) openApp();
    });

    el('continue-with-sample').addEventListener('click', ()=>{
      allSubjectsData = { General: DEFAULT_SAMPLE };
      el('loader-status').textContent = 'Using embedded sample';
      openApp();
    });

    window.addEventListener('load', async ()=>{
      const pre = el('debug-pre'); if (pre) pre.textContent = '';
      try{
        const ok = await tryLoadFromPath('./questions.json');
        if (ok) openApp();
      }catch(e){
        debug('Auto-load attempt failed: '+e);
      }
    });

    // --- APP UI ---
    function openApp(){
      el('loader-card').classList.add('hidden');
      el('app-card').classList.remove('hidden');
      renderWelcomeScreen();
    }

    function renderWelcomeScreen(){
      const subjects = Object.keys(allSubjectsData);
      const subjectOptions = ['All', ...subjects].map(s=>`<option value="${s}">${s}</option>`).join('');
      const html = `
        <header>
          <h1>⚔️ CBT Mode — 200 Questions</h1>
          <p class="muted">Choose subject or keep 'All' to run the full CBT (Mathematics 50, Physics 25, Chemistry 25, CSE 100). Questions will not repeat.</p>
        </header>
        <div class="question-card">
          <div class="controls">
            <input id="name" type="text" placeholder="Your name (e.g., Mahesh)" />
            <select id="subject">${subjectOptions}</select>
            <button id="start">Start CBT</button>
          </div>
          <div style="margin-top:10px" class="small muted">Subjects detected: ${subjects.join(', ') || 'None'}</div>
        </div>
      `;
      el('app-container').innerHTML = html;
      el('start').addEventListener('click', ()=>{
        userName = el('name').value.trim() || 'Hunter';
        const subj = el('subject').value;
        prepareQuiz(subj);
        if (!quizData.length) return alert('No questions found for selected subject or not enough questions for CBT. Check debug.');
        currentQuestionIndex = 0; score = 0; userAnswers = [];
        remainingSeconds = Math.max(quizData.length * TIME_PER_QUESTION, 60); // at least 1 minute
        startTimer(); renderQuizScreen();
      });
    }

    function findSubjectKeyByKeyword(keyword){
      const keys = Object.keys(allSubjectsData);
      const low = keyword.toLowerCase();
      for (const k of keys){ if (k.toLowerCase().includes(low)) return k; }
      return null;
    }

    function prepareQuiz(selectedSubject){
      if (selectedSubject !== 'All'){
        const list = Array.isArray(allSubjectsData[selectedSubject]) ? allSubjectsData[selectedSubject] : [];
        quizData = list.map((q,idx)=>normalizeQuestion(q, idx)).slice();
        quizData = quizData.sort(()=>0.5 - Math.random());
        return;
      }

      const keyMath = findSubjectKeyByKeyword('math') || findSubjectKeyByKeyword('mathematics');
      const keyPhysics = findSubjectKeyByKeyword('phys');
      const keyChem = findSubjectKeyByKeyword('chem');
      const keyCSE = findSubjectKeyByKeyword('cse') || findSubjectKeyByKeyword('computer') || findSubjectKeyByKeyword('cs');

      const pools = {
        Mathematics: keyMath ? (allSubjectsData[keyMath] || []) : [],
        Physics: keyPhysics ? (allSubjectsData[keyPhysics] || []) : [],
        Chemistry: keyChem ? (allSubjectsData[keyChem] || []) : [],
        CSE: keyCSE ? (allSubjectsData[keyCSE] || []) : []
      };

      const missing = [];
      for (const subj of Object.keys(CBT_DISTRIBUTION)){
        const available = pools[subj].length;
        const needed = CBT_DISTRIBUTION[subj];
        if (available < needed) missing.push(`${subj} needs ${needed} but has ${available}`);
      }
      if (missing.length){
        debug('CBT assemble failed: insufficient pool sizes - ' + missing.join('; '));
        const allQuestionsFlat = [];
        for (const k of Object.keys(allSubjectsData)){
          const arr = Array.isArray(allSubjectsData[k]) ? allSubjectsData[k] : [];
          arr.forEach((q,idx)=> allQuestionsFlat.push(normalizeQuestion(q, allQuestionsFlat.length)));
        }
        if (allQuestionsFlat.length >= 200){
          quizData = allQuestionsFlat.sort(()=>0.5 - Math.random()).slice(0,200);
          debug('CBT assembled from pooled questions (fallback). Total: '+quizData.length);
          return;
        } else {
          debug('Not enough total questions to build CBT. Found: '+allQuestionsFlat.length);
          quizData = [];
          return;
        }
      }

      const assembled = [];
      for (const subj of Object.keys(CBT_DISTRIBUTION)){
        const key = subj === 'Mathematics' ? keyMath : subj === 'Physics' ? keyPhysics : subj === 'Chemistry' ? keyChem : keyCSE;
        const arr = (allSubjectsData[key] || []).map((q,idx)=>normalizeQuestion(q, idx));
        const shuffled = arr.slice().sort(()=>0.5 - Math.random());
        const pick = shuffled.slice(0, CBT_DISTRIBUTION[subj]);
        assembled.push(...pick);
      }

      const uniqueMap = new Map();
      assembled.forEach(q=>{
        const key = q.id !== undefined ? q.id : JSON.stringify(q).slice(0,60);
        if (!uniqueMap.has(key)) uniqueMap.set(key, q);
      });
      quizData = Array.from(uniqueMap.values()).slice(0,200).sort(()=>0.5 - Math.random());
      debug('CBT assembled exact distribution. Total questions: '+quizData.length);
    }

    function normalizeQuestion(q, idx){
      return {
        id: q.id !== undefined ? q.id : (idx + Math.floor(Math.random()*1000000)),
        question: q.question_text || q.question || '[No question text]',
        options: Array.isArray(q.options) ? q.options : (q.choices || []).slice() || [],
        rawCorrect: q.correct_answer !== undefined ? q.correct_answer : q.correct
      };
    }

    function normalizeCorrectIndex(question){
      const raw = question.rawCorrect;
      if (raw === undefined || raw === null) return null;
      if (typeof raw === 'number') return raw;
      if (typeof raw === 'string'){
        const t = raw.trim();
        if (/^[A-Za-z]$/.test(t)) return t.toUpperCase().charCodeAt(0)-65;
        const n = Number(t);
        if (!Number.isNaN(n)) return n;
        const idx = (question.options||[]).findIndex(o=>o && o.toString().trim().toLowerCase()===t.toLowerCase());
        if (idx!==-1) return idx;
      }
      return null;
    }

    function renderQuizScreen(){
      const q = quizData[currentQuestionIndex];
      if (q.correctIndex === undefined) q.correctIndex = normalizeCorrectIndex(q);
      const progress = Math.round(((currentQuestionIndex+1) / quizData.length) * 100);
      const optionsHtml = (q.options || []).map((opt,i)=>`<div class="option" data-i="${i}">${String.fromCharCode(65+i)}. ${opt}</div>`).join('') || '<div class="muted">No options provided</div>';
      const html = `
        <header><h1>Question ${currentQuestionIndex+1} / ${quizData.length}</h1><p class="muted">Player: ${userName} — Progress: ${progress}%</p></header>
        <div class="question-card card" style="margin-top:12px">
          <div style="font-weight:700">${q.question}</div>
          <div id="options">${optionsHtml}</div>
          <div style="margin-top:12px" class="flex">
            <div id="timer-display" class="small muted">Time: ${formatTime(remainingSeconds)}</div>
            <div style="margin-left:auto"><button id="next-btn" disabled>Next</button></div>
          </div>
        </div>
      `;
      el('app-container').innerHTML = html;
      document.querySelectorAll('#options .option').forEach(elm=>{
        elm.addEventListener('click', ()=>{
          document.querySelectorAll('#options .option').forEach(x=>x.classList.remove('selected'));
          elm.classList.add('selected');
          el('next-btn').disabled = false;
        });
      });
      el('next-btn').addEventListener('click', ()=>{
        const picked = document.querySelector('#options .option.selected');
        const pickedIndex = picked ? Number(picked.getAttribute('data-i')) : null;
        const isCorrect = (q.correctIndex !== null) ? pickedIndex === q.correctIndex : false;
        if (isCorrect) score++;
        userAnswers.push({ id: q.id, question: q.question, selected: pickedIndex, correct: q.correctIndex, isCorrect });
        if (picked){
          if (q.correctIndex!==null){
            if (pickedIndex===q.correctIndex) picked.classList.add('correct'); else picked.classList.add('wrong');
            const correctEl = document.querySelector(`#options .option[data-i=\"${q.correctIndex}\"]`);
            if (correctEl) correctEl.classList.add('correct');
          }
        }
        currentQuestionIndex++;
        if (currentQuestionIndex >= quizData.length) return endQuiz();
        setTimeout(renderQuizScreen, 400);
      });
    }

    function formatTime(sec){ const m=Math.floor(sec/60); const s=sec%60; return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`; }

    function startTimer(){ if (timerInterval) clearInterval(timerInterval); timerInterval = setInterval(()=>{ remainingSeconds--; if (remainingSeconds<=0){ clearInterval(timerInterval); endQuiz(); return; } const td = el('timer-display'); if (td) td.textContent = 'Time: '+formatTime(remainingSeconds); },1000); }

    function endQuiz(){ if (timerInterval) clearInterval(timerInterval); renderResults(); }

    function renderResults(){
      const perc = quizData.length? Math.round(score/quizData.length*100) : 0;
      let rank='E-RANK', msg='Try again.';
      if (perc>=90){rank='S-RANK'; msg='Legendary!'} else if (perc>=80){rank='A-RANK'; msg='Excellent!'} else if (perc>=70){rank='B-RANK'; msg='Great'} else if (perc>=60){rank='C-RANK'; msg='Good'}
      const answersHtml = userAnswers.map((a,idx)=>`<div class="small">${idx+1}. ${a.question} — Selected: ${a.selected===null? 'None' : String.fromCharCode(65+a.selected)} — ${a.isCorrect? '✓':'✗'}</div>`).join('');
      const html = `
        <header><h1>Results — ${rank}</h1><p class="muted">${msg} — Score: ${score} / ${quizData.length} (${perc}%)</p></header>
        <div class="card">${answersHtml}</div>
        <div style="margin-top:12px" class="flex">
          <button id="retry">Retry</button>
          <button id="back" class="ghost">Back to subjects</button>
        </div>
      `;
      el('app-container').innerHTML = html;
      el('retry').addEventListener('click', ()=>{ currentQuestionIndex=0; score=0; userAnswers=[]; remainingSeconds = Math.max(quizData.length * TIME_PER_QUESTION, 60); startTimer(); renderQuizScreen(); });
      el('back').addEventListener('click', ()=>{ renderWelcomeScreen(); });
    }

    // Expose one-line helper to load JSON programmatically (useful for tests)
    window.__loadQuestionsFromString = function(jsonString){ const ok = parseAndSetJSON(jsonString); if (ok) openApp(); return ok; };

  </script>
</body>
</html>
